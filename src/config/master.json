[
  {
    "id": 1,
    "title": "Modern JavaScript",
    "master": [
      {        
        "title": "Modern JavaScript for React - ES6 and beyond",
        "competence": [
          "Dapat memahami apakah ES6 itu",          
          "Dapat memahami kenapa harus pakai ES6",
          "Dapat mengetahui fitur-fitur apa saja yang ada di ES6"
        ],
        "course": [          
          {
            "title":"Sejarah",
            "content":"Perusahaan bernama Netscape/Mozilla adalah pencipta pertama JavaScript yang digunakan untuk melakukan manipulasi HTML/DOM di browser Netscape/Firefox. Karena kesuksesan Netscape mengembangkan bahasa JavaScript, Microsoft pun tak mau ketinggalan, mereka menciptakan bahasa serupa bernama JScript. Perbedaan inilah yang menyebabkan hasil yang berbeda ketika website dijalankan di browser Netscape dan IE. Untuk mengatasi hal tersebut, dibuatlah EcmaScript yang merupakan standarisasi dari client-side scripting. Sehingga JavaScript dan JScript disepakati sebagai implementasi dari EcmaScript, termasuk juga Action Script. Namun karena JavaScript adalah bahasa yang paling pertama dibuat, maka orang-orang lebih mengistilahkan EcmaScript dengan Sebutan JavaScript.EcmaScript sendiri sebenarnya dilahirkan dari JavaScript asli, sehingga secara fitur, tidak ada perbedaan antara JavaScript dan EcmaScript. Sedangkan untuk versi JScript sendiri, ada sedikit perbedaan namun masih tetap mendukung fitur-fitur yang ada di versi standar EcmaScript. JavaScript yang kita kenal saat ini, adalah EcmaScript versi 5 (ES5). EcmaScript sendiri saat ini sudah sampai versi 6 (ES6/ES2015), namun belum support untuk semua browser. Sehingga untuk menggunakannya, ES6 harus ditranspile (dirubah) menjadi ES5/JavaScript dengan tool yang bernama Babel."
          },
          {
            "title":"Javascript ES6",
            "content":"Javascript ES6 membawa sintaks-sintaks baru dan fitur-fitur baru yang mengagumkan untuk membuat kode kita lebih modern dan mudah untuk dibaca. Ini membuat kita hanya menuliskan sedikit kode dan lebih banyak manfaatnya. ES6 memperkenalkan kita pada fitur-fitur seperti arrow functions, template literal, class, destructuring, modules dan masih banyak lagi. Pada materi berikutnya kita akan belajar bagaimana fitur-fitur ini bekerja."
          }
        ],
        "keywords": [
          "JavaScript(JS)",
          "es6 2015"
        ],
        "notes": [
          "React adalah sebuah library yang digunakan untuk membuat aplikasi dengan bahasa pemrograman JavaScript",
          "Standarisasi JavaScript sekarang memakai es6 2015"
        ],
        "summarize": "Untuk memulai belajar React diharuskan terlebih dahulu harus mengerti bahasa pemrograman JavaScript, selain itu juga di haruskan untuk memahami sintak-sintak es6 2015. Seperti let, const, template literal, arrow functions, class syntax, destructuring, default parameters, Rest operator, Spread operator, module dan promises. Karena dalam pembuatan aplikasi-aplikasi JavaScript, kita akan sering menggunakan sintaks-sintaks es6 kedepannya.",
        "useable_link": [
          {
            "url": "https://www.slideshare.net/rizafahmi/essentials-and-impactful-features-of-es6",
            "title": "ES6 2015"
          },
          {
            "url": "https://www.tutorialspoint.com/javascript/",
            "title": "Javacsript"
          }
        ]
      },
      {
        "title": "Let and Const vs Var",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "var",
          "let",
          "const",
          "scope"
        ],
        "notes": [
          "var adalah deklarasi variabel global.",
          "let hampir sama dengan var namun hanya mencakup pada block scope.",
          "const hanya bisa dipakai di dalam block scope dan bersifat constant tidak bisa dirubah.",
          "selain const, deklarasi variabel bisa dirubah."
        ],
        "summarize": "pada dasarnya deklarasi variabel di javascript hanya terbagi ke dalam 3 bagian var, let, dan const. sesuai dengan scope dan kegunaannya. rekomendasi untuk sekarang karena hampir semua browser telah support ES6 2015 maka untuk deklarasi variabel lebih direkomendasikan untuk memakai let daripada var. Alasannya sederhana karena var lebih global scope maka jika kita mendeklarasikan variabel dengan var di awal code dan jika code ini sudah jutaan dan kita deklarasikan dengan nama yang sama maka kode yang berada di awal tadi akan tertimpa. Sehingga menyebabkan kode tadi sudah tidak berfungsi lagi.",
        "useable_link": [
          {
            "url":"https://medium.com/coderupa/es6-var-let-const-apa-bedanya-1cd4daaee9f0",
            "title":"var, let, const dan scope"
          }
        ]
      },
      {
        "title": "Arrow Functions, Class syntax, Template literal",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "arrow function",
          "template literal",
          " Class syntax"
        ],
        "notes": [
          "Arrow function merupakan penyederhanaan penulisan function di JavaScript",
          "Simbol arrow function adalah => ",
          "Salah satu fitur yang banyak digunakan dari ES6 adalah arrow function. Dari namanya kita sudah bisa mengira, ini adalah fitur pada function. Salah satu kegunaan dari fitur ini adalah syntax javascript kita menjadi lebih ringkas.",
          "Salah satu keuntungan kembali kita menggunakan arrow function adalah kita bisa menggunakan ‘this’ tanpa perlu membuat that = this. Ada kawan-kawan yang pernah pakai that = this?",
          "Syntax Arrow Function pada ES6 secara umum seperti ini. () => { ... } // no parameter",
          "Class dapat mencakup 2 hal berikut : Sebuah fungsi konstruktor diinisialisasi dengan sejumlah parameter, yang akan ditugaskan sebagai properti this, mengacu pada fungsi itu sendiri. Huruf pertama dari pengidentifikasi akan dikapitalisasi oleh konvensi. Kita tahu fungsi konstruktor dimaksudkan untuk menjadi cetak biru objek dengan huruf kapital huruf pertama dari penginisialisasi (yang opsional) dan melalui keakraban dengan sintaksis. Kata classkunci berkomunikasi dengan cara yang lebih mudah, tujuan fungsi kami.Satu-satunya perbedaan dalam sintaks inisialisasi adalah menggunakan classkata kunci alih-alih function, dan menetapkan properti di dalam constructor()metode."

        ],
        "summarize": "Arrow function merupakan cara penulisan syntax dari ES6 dengan tujuan utamanya adalah membuat syntax javascript kita menjadi lebih ringkas. Sedangkan Class suatu deklarasi kelaf dan class memiliki 2 jenis parameter yaitu function dan constructor.",
        "useable_link": [
          {
            "url": "https://medium.com/@renopp/kenalan-dengan-es6-javascript-introduction-variable-arrow-function-part1-6bd5c148473b",
            "title": "Arrow Function"
          },
          {
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor",
            "title": "Class Syntax"
          },
          {
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals",
            "title": "Template Literals"
          }
        ]
      },
      {
        "title": "Destructuring",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "Destructuring"
        ],
        "notes": [
          "Destructuring/Destrukturisasi adalah cara yang mudah untuk mengekstraksi beberapa nilai dari variabel, objek dan Array yang tersimpan.",
          "Itu dapat digunakan di lokasi yang menerima data. Cara mengekstrak yang ditentukan melalui nilai pola"
        ],
        "summarize": "Singkatnya, destructuring itu adalah bagaimana kita menyusun nilai dari variabel, object maupun array, menjadi lebih terstruktur",
        "useable_link": [
          {
            "url": "https://icalrn.id/destructuring-assignment-pada-javascript/",
            "title": "Destructuring Assignment"
          }
        ]
      },
      {
        "title": "Default parameters, Rest parameter, Spread operator",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "default parameters",
          "rest parameter",
          "spread operator"
        ],
        "notes": [
          "Default Parameter adalah membuat nilai/value parameter default pada sebuah function",
          "dengan memberi value langsung kepada parameter sebuah function sehingga tidak perlu membuat",
          "variabel baru untuk memberikan value pada parameter yg mempunyai nilai default.",
          "Spread Operator adalah mengumpulkan dan memanggil seluruh nilai array pada sebuah function atau variabel.",
          "Sebuah Spread Operator biasa di awali dengan tanda titik tiga (...)",
          "Rest Parameter sama dengan Spread Operator diawali dengan tanda titik tiga, namun pada rest parameter",
          "hanya mengambil nilai sisa dari sebuah array"
        ],
        "summarize": "Dengan menggunakan Default parameter, spread operator dan rest parameter dari es6 membuat kode kita menjadi lebih clean code",
        "useable_link": [
          {
            "url": "https://css-tricks.com/lets-learn-es2015/#es2015-rest%20parameters",
            "title": "more detail about.."
          }
        ]
      },
      {
        "title": "Iterators and functional programming in JS",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "Itertors",
          "next()",
          "for...of"
        ],
        "notes": [
          "Iterator adalah objek yang mendefinisikan urutan dan berpotensi mengembalikan nilai pada saat penghentiannya. ",
          "Lebih khusus iterator adalah objek apa pun yang mengimplementasikan protokol Iterator dengan memiliki  next()metode yang mengembalikan objek dengan dua properti  value: nilai berikutnya dalam urutan; dan done, yang truejika nilai terakhir dalam urutan sudah dikonsumsi. Jika value ada di sampingnya done, itu adalah nilai pengembalian iterator.",
          "The for...ofpernyataan menciptakan iterasi loop di atas benda iterable , termasuk: built-in String, Array,  Arraybenda -seperti (misalnya,  argumentsatau  NodeList), TypedArray, Map, Set, dan user-defined iterables. Itu meminta kait iterasi kustom dengan pernyataan yang akan dieksekusi untuk nilai setiap properti objek yang berbeda.",
          "String, Array, TypedArray, MapDan Setsemua built-in iterables, karena prototipe mereka benda semua memiliki Symbol.iteratormetode.",
          "Sebelum ES6 tidak ada cara dalam javascript untuk menjeda mengeksekusi suatu fungsi di beberapa titik, kemudian datang kemudian ke titik yang sama dan melanjutkan eksekusi fungsi.  Tetapi dengan fungsi generator kita dapat melakukan itu, karena fungsi generator ketika dieksekusi mengembalikan sebuah iterator, dan alih-alih berhenti di setiap nilai / elemen dan mengembalikan iteratorHasil dengan masing-masing .next (), fungsi generator berhenti di setiap kata kunci hasil dan mengembalikan nilai di sebelah jika ada. Untuk menentukan fungsi generator, Anda perlu menambahkan * antara fungsi kata kunci dan nama fungsi.",
          "String dapat diubah, tetapi mereka mengulangi lebih dari titik kode Unicode, yang masing-masing terdiri dari satu atau dua karakter JavaScript:",
          "Peta adalah iterables atas entri mereka. Setiap entri dikodekan sebagai pasangan [kunci, nilai], sebuah Array dengan dua elemen. Entri selalu diiterasi secara deterministik, dalam urutan yang sama di mana mereka ditambahkan ke peta.",
          "Set adalah iterables atas elemen mereka (yang iterated di dalam urutan yang sama di mana mereka ditambahkan ke Set).",
          "Array (dan array yang diketik) adalah iterables atas elemen mereka:"
        ],
        "summarize": " terator adalah bagian dari apa yang disebut protokol ( antarmuka ditambah aturan untuk menggunakannya ) untuk iterasi. Karakteristik utama dari protokol ini adalah sekuensial: iterator mengembalikan nilai satu per satu. Itu berarti bahwa jika struktur data yang dapat diulang adalah non-linier (seperti pohon), iterasi akan membuat garis itu. Iterable sumber data yaitu Peta, Set, Array",
        "useable_link": [
          {
            "url": "https://medium.com/dubizzletechblog/introduction-to-javascript-iterables-iterators-and-generators-a26be413dfd9",
            "title": "Iterators and functional"
          }
        ]
      },
      {
        "title": "Modules",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "import",
          "define",
          "require"
        ],
        "notes": [
          "Modul adalah bagian dari program yang menentukan bagian mana yang menjadi sandarannya dan fungsionalitas apa yang disediakan untuk modul lain untuk digunakan",
          "Memecah-mecah kode program menjadi banyak bagian-bagian yang lebih kecil. Biasanya bagian kecil dari kode ini disebut dengan nama modul. Setiap kode modul memiliki peranan spesifik, dan biasanya sebuah modul terdiri dari beberapa fungsi. Semakin spesifik dan sejenis fungsi yang terkumpul di dalam sebuah modul semakin baik. Tingkat kecocokan fungsi-fungsi di dalam modul ini kita kenal dengan istilah cohesion.",
          "Setelah kode program dipecah menjadi bagian-bagian kecil, masing-masing komponen kecil ini kemudian dapat kita hubungkan untuk menjadi sebuah komponen yang lebih besar atau bahkan program jadi."
        ],
        "summarize": "Pembuatan modul dari kode program dapat dilakukan dengan banyak cara, seperti mengumpulkan fungsi-fungsi ke dalam kelas atau objek, dan kmeudian memasukkan kode tersebut ke dalam sebuah file. Bagian kedua, di mana kita dapat memanggil modul-modul lain dengan mudah, biasanya didukung secara langsung oleh bahasa pemrograman yang digunakan. Contohnya, pada bahasa Java kita memiliki perintah import dan pada C# kita memiliki perintah using. ",
        "useable_link": [
          {
            "url": "https://bertzzie.com/knowledge/javascript-lanjut/Javascript-Module-System.html",
            "title": "Modules"
          }
        ]
      },
      {
        "title": "Promises",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          ".then",
          ".catch"
        ],
        "notes": [
          "Promise adalah built in method or built in function yang terdapat pada java script yang berguna untuk menangkap event atau suatu kejadian ketika menggunakan asyncronous java script , dimana kita dapat melihat suatu event berhasil dilakukan atau gagal untuk dilakukan ",
          "untuk menggunakan mendapatkan nilai true , atau menangkap bahwa event berhasil dilakukan menggunakan methode .then",
          "untuk mendapatkan nilai false , atau menangkap bahwa event gagal dilakukan menggunakan methode .cacth"
        ],
        "summarize": "Promise berguna untuk mendapatkan nilai true atau false , dimana pada saat kita melakukan asyncronous javascript kita dapat dengan mudah untuk mendapatkan hasil apakah event yang  kita lakukan berhasil dilakukan atau gagal dilakukan ",
        "useable_link": [
          {
            "url": "https://blog.andi.dirgantara.co/promise-pada-javascript-24e544c8bd0d",
            "title": "more detail about promise"
          }
        ]
      },
      {
        "title": "ES6 exercise using TDD",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      }
    ]
  },
  {
    "id": 2,
    "title": "Thinking in React",    
    "master": [
      {
        "title": "The Imperative to Declarative Shift",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Componentization",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "What is React made up of",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "detail": [
          "Props & State",
          "Classes Vs. Functions",
          "One way data binding"
        ],
        "useable_link": []
      },
      {
        "title": "Composition",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Virtual DOM and JSX",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "Virtual DOM",
          "JSX"
        ],
        "notes": [
          "Virtual DOM adalah API pemrograman untuk dokumen HTML dan XML.",
          "Ini mendefinisikan struktur logis dokumen dan cara dokumen diakses dan dimanipulasi.",
          "DOM adalah singkatan dari Document Object Model.",
          "Dan JSX merupakan sebuah sintaks extension pada javascript, untuk di gunakan pada React.",
          "Sintaks kode JSX merupakan kode HTML yang di sematkan pada kode javascript.",
          "JSX bukanlah sintaks javascript, sehingga browser tidak bisa membaca sintaks ini.",
          "Dibutuhkan sebuah JSX compiler yang di gunakan untuk menerjemahkan JSX kedalam bahasa regular javascript agar bisa terbaca oleh browser."
        ],
        "summarize": "Singkatnya dengan virtual DOM kita ngebuat sebuah abstraksi DOM yang biasa disebut sebagai component. Component ini lah yang nanti nya di render ke dalam file HTML dengan JSX maka itu semua dapat terjadi",
        "useable_link": [
          {
            "url": "https://ekaprasasti.com/memulai-reactjs-dan-dasar-jsx/",
            "title": "ReactJSDOM&JSX"
          },
          {
            "url": "https://kudo.co.id/engineering/2017/02/16/mengenal-virtual-dom-pada-reactjs/",
            "title": "Conclusion Virtual DOM"
          }
        ],
        "detail": [
          "React Components, Elements, and Instances",
          "JSX and React.createElement"
        ]
      },
      {
        "title": "Developer tools",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      }
    ]
  },
  {
    "id": 3,
    "title": "Routing & Data Fetching",    
    "master": [
      {
        "title": "React Router v4",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "detail": [
          "Declarative routing",
          "Implementing a master-detail web application"
        ],
        "useable_link": []
      },
      {
        "title": "Component lifecycle",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": [
          "component lifecycle"
        ],
        "notes": ["Component Lifecycle adalah alur jalannya pengeksekusian component dari awal hingga akhir"],
        "summarize": "Beberapa method mempunyai prefix will dan did yang menunjukkan kapan method tersebut akan dieksekusi.",
        "useable_link": [
          {
            "url": "https://medium.com/skyshidigital/react-component-lifecycle-wajib-bagi-yang-sedang-belajar-react-b46049b97788",
            "title": "Lifecycle Component ES6"
          }
        ]
      },
      {
        "title": "Data management",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "detail": [
          "Presentational Components Vs. Container Components",
          "Data fetching"
        ],
        "useable_link": []
      }
    ]
  },
  {
    "id": 4,
    "title": "Forms & Auth",
    "master": [
      {
        "title": "Forms management in React",
        "competence": [
          "Dapat membuat form dengan aturan react"
        ],
        "course": [
          {
            "title":"Dasar Controlled Component dan Uncontrolled Component",
            "content":"Form pada suatu aplikasi sangatlah penting dan pasti digunakan(minimal untuk form login). Form pada React memiliki behavior yang berbeda jika dibandingkan dengan form html biasannya. Bagaimanakah cara membuat form dengan aturan react ? silahkan simak ulasan ini. Pertama-tama kita akan membahas cara konvensional pembuatan form pada html biasa (non react). yakni dengan menggunakan syntax <form> yang memiliki salah satu attribute berupa method. Isi dari attribute tersebut adalah POST dan GET. Jika memilih method POST maka akan disubmit ke halaman lain (meksipun diarahkan pada halaman yang sama tetap akan melakukan reload) begitu pula dengan method GET. Berikut ini adalah contoh form sederhana yang menerima input berupa nama yang dibuat dengan cara konvensional pada html umumnya. Elemen form seperti dibawah ini bekerja sangat berbeda dibandingkan DOM pada react. Namun persamaanya adalah form konvensional seperti dibawah ini memiliki elemen penyusun yang sama yakni form input seperti <input>, <select> , <option> ataupun <textarea> serta <input type=button> untuk mensubmit form tersebut. Lihat di sini https://degananda.com/react-form-handling-dasar-controlled-component/. Pada react default behavior seperti itu tentunnya sangat tidak di izinkan untuk dilakukan meningat react adalah library yang digunakan untuk membuat SPA(Single page application). Aplikasi SPA tidak di izinkan untuk melakukan refresh (meski satu halaman) melainkan reload hanya pada komponen-komponen tertentu oleh karena itu disebut sebagai SPA. Perhatikan gambar dibawah ini saat form tersebut di klik submit maka yang terjadi adalah reload page.Form html diatas akan dihandle dengan menggunakan javascript sesuai dengan aturan react. Terdapat dua metode mengcontrol pada react yakni controlled component dan uncontrolled component. Dalam kebanyakan kasus, kami merekomendasikan penggunaan komponen yang terkontrol untuk mengimplementasikan formulir.Di sebuah controlled component, formulir data ditangani oleh komponen React. Alternatifnya adalah uncontrolled components, di mana data formulir ditangani oleh DOM itu sendiri.Untuk menulis  uncontrolled component, alih-alih menulis pengendali acara untuk setiap pembaruan State, Anda bisa menggunakan referensi untuk mendapatkan nilai formulir dari DOM. Karena uncontrolled component menyimpan sumber kebenaran dalam DOM, kadang-kadang lebih mudah untuk mengintegrasikan kode React dan non-React ketika menggunakan uncontrolled component. Ini juga bisa menjadi kode yang sedikit kurang jika Anda ingin cepat dan kotor. Jika tidak, Anda biasanya harus menggunakan komponen yang dikendalikan. Jika masih belum jelas jenis komponen apa yang harus Anda gunakan untuk situasi tertentu, Anda mungkin menemukan artikel ini pada input yang dikontrol dan tidak terkontrol untuk membantu."
          }
        ],
        "keywords": [
          "Dasar Controlled Components",
          "Dasar Uncontrolled Components"
        ],
        "notes": [
          "Dasar Controlled Component : Syntax <input>, <select> , <textarea> dan form input lainnya melakukan manajemen “state” pada dirinnya sendiri dan state tersebut akan berubah sesuai dengan isi dari input tersebut. Pada react kita telah mengenah bahwa state bersifat mutable a.k.a dapat berubah nilainya. Perubahan tersebut dapat kita lakukan melalui fungsi setState().",
          "Form pada react harus kita atur flow dari state. Baik pada saat form input pertama kali dibuat kemudian terjadi perubahan hingga pada saat disubmit oleh user. Hal seperti inilah yang disebut dengan controlled component. Pengaturan tersebut kita lakukan menggunakan javascript. Contohnya kita akan mentransformasikan kode html konvensional diatas menjadi react controlled component (form). Kasus dibawah ini form berupa satu buah <input>. Code lihat di sini https://degananda.com/react-form-handling-dasar-controlled-component/. ",
          "Ada beberapa hal yang perlu dilakukan dalam membuat controlled component pada react (konteks : form). Untuk mempermudah memahami berikut ini adalah langkah-langkahnya : ",
          "Buat form, Form handler menggunakan attribute onSubmit , ingat tulisan menggunakan camelCase,",
          " Buat input , contoh diatas adalah <input type=”text”> Berikan dua atribut (wajib) pada input yakni value dan onChange",
          "Buat state yang merupakan model dari form. Contoh diatas object formValue dengan child Berupa name",
          "Atribut value pada input diambil dari nilai state",
          "Atribut onChange berikan nilai berupa formHandler yang akan memanggil fungsi setState. Fungsinnya adalah merubah state pada komponen.",
          "Pada form handler (onSubmit) jangan lupa untuk memberikan fungsi e.preventDefault() untuk menghilangkan default behavior dari browser agar saat di klik submit tidak mengarahkan ke halaman baru.",
          "Jangan lupa melakukan bind terhadap handler pada form. hal ini wajib , jika handler tidak dilakukan binding terhadap komponen maka tidak dapat menggunakan fungsi this. Padahal fungsi this tersebut digunakan untuk merubah state dari komponen (setState).",
          "untuk mengambil nilai dari suatu input kita menggunakan handler dimana fungsi untuk mengambil valuenya adalah event.target.value. Jika lupa apa saja nilai pada event tersebut dapat melakukan logging pada browser dengan perintah console.log. Hasil bisa lihat disini https://degananda.com/react-form-handling-dasar-controlled-component ",
          "Uncontrolled Components: Default Values, dalam  lifecycle rendering React, atribut nilai pada elemen formulir akan menimpa nilai dalam DOM. Dengan uncontrolled component, Anda sering ingin React menentukan nilai awal, tetapi membiarkan pembaruan berikutnya tidak terkontrol. Untuk menangani kasus ini, Anda dapat menentukan atribut defaultValue alih-alih nilai. Contoh https://reactjs.org/docs/uncontrolled-components.html. The file input Tag, Dalam HTML, <input type = file > memungkinkan pengguna memilih satu atau lebih file dari penyimpanan perangkat mereka untuk diunggah ke server atau dimanipulasi oleh JavaScript melalui File API. <input type = file /> Dalam React, <input type = file /> selalu merupakan komponen yang tidak terkontrol karena nilainya hanya dapat ditetapkan oleh pengguna, dan tidak secara terprogram."

        ],
        "summarize": "Form pada react harus kita atur flow dari state. Baik pada saat form input pertama kali dibuat kemudian terjadi perubahan hingga pada saat disubmit oleh user. Hal seperti inilah yang disebut dengan controlled component.Ini berkaitan dengan komponen DOM stateful (elemen formulir) dan dokumen React menjelaskan perbedaan: Komponen Terkendali adalah komponen yang mengambil nilainya saat ini melalui alat peraga dan memberi tahu perubahan melalui panggilan balik seperti onChange. Komponen induk Controls itu dengan menangani panggilan balik dan mengelola statusnya sendiri dan meneruskan nilai-nilai baru sebagai alat peraga ke komponen yang dikontrol. Anda juga bisa menyebutnya dumb component. Komponen yang tidak terkontrol adalah komponen yang menyimpan keadaannya sendiri secara internal, dan Anda meminta DOM menggunakan referensi untuk menemukan nilai saat ini ketika Anda membutuhkannya. Ini sedikit lebih mirip HTML tradisional.",
        "detail": [
          "Controlled Components",
          "Uncontrolled Components"
        ],
        "useable_link": [
          {
            "url": "https://degananda.com/react-form-handling-dasar-controlled-component/",
            "title": "Dasar Controlled Component"
          },
          {
            "url": "https://reactjs.org/docs/uncontrolled-components.html",
            "title": "Dasar Uncontrolled Components"
          }
        ]
      },
      {
        "title": "Authentication",
        "competence": [
          "Dapat memahami Struktur File Authentication ",
          "Dapat membuat system Authentication"
        ],
        "course": [
          {
            "title":"Using JWT (JSON Web Tokens) to authorize users and protect API routes",

            "content":"Jadi backend Anda memiliki beberapa rute API yang perlu dilindungi dan beberapa pengguna yang membutuhkan otorisasi. Sama seperti saya pada satu titik, Anda mungkin bertanya-tanya bagaimana ini bisa dicapai. Untungnya, kami memiliki JSON Web Tokens (JWT) (antara lain) untuk itu. Apa itu JWT? Tidak ada cara yang lebih baik untuk menjelaskannya selain langsung dari situs web JWT:JSON Web Token (JWT) adalah standar terbuka (RFC 7519) yang mendefinisikan cara yang ringkas dan mandiri untuk mentransmisikan informasi antar pihak secara aman sebagai objek JSON. Informasi ini dapat diverifikasi dan dipercaya karena ditandatangani secara digital. JWT dapat ditandatangani menggunakan rahasia (dengan algoritma HMAC) atau pasangan kunci publik / pribadi menggunakan RSA atau ECDSA.Salah satu kasus penggunaan terbesar untuk JWT adalah otorisasi. Kami dapat membuat token JWT di backend yang khusus untuk pengguna, meneruskan token JWT ini ke frontend, dan kemudian frontend kami dapat mengirimkan token ini bersama permintaan untuk mengakses rute API yang dilindungi.Token JWT dapat diberikan waktu kedaluwarsa. Mereka juga dapat dihasilkan tanpa kedaluwarsa, namun saya percaya ini adalah praktik terbaik untuk memastikan token Anda memiliki kedaluwarsa dan diperbarui pada interval tertentu. Ini akan mengurangi ancaman satu token tunggal yang dicuri dan digunakan untuk mengakses rute berulang-ulang.Mari kita sentuh keamanan token JWT untuk beberapa saat lagi. Ketika token JWT dihasilkan, ada rahasia yang digunakan untuk menghasilkan token. Hanya server yang harus mengetahui rahasia ini. Jika seseorang mengubah data yang terkandung dalam JWT, server akan gagal untuk memecahkan kode itu. Ini berarti server dapat mempercayai JWT yang dapat diuraikan dan diverifikasi. Seorang hacker juga dapat mencegat lalu lintas jaringan antara server dan klien untuk mendapatkan token JWT (seperti halnya cookie). Ini dapat dicegah dengan selalu mengirim token bolak-balik melalui HTTPS. Adalah wajib bahwa HTTPS harus digunakan dengan JWT.Saya pasti akan merekomendasikan membaca lebih mendalam tentang keamanan token JWT. Ini sangat penting, terutama jika aplikasi Anda berisi data sensitif."
          }
        ],
        "keywords": [
          "File Structure",
          "User Model",
          "Generating and verifying JWT Tokens"
        ],
        "notes": [
          "File Structure",
          "Berikut adalah struktur file dasar dari contoh ini: https://cdn-images-1.medium.com/max/800/1*q-Xo_-nu6763LtMuseyEYw.png Cukup mudah. Kami memiliki pengaturan user pengguna dummy ’yang sangat sederhana di server / model / dummyUser.js yang akan kami gunakan untuk mengejek pengguna dalam basis data, memungkinkan kami untuk‘ masuk log ’dan menghasilkan token JWT. Lebih lanjut tentang itu dalam beberapa.",
          "User Model",
          "Seperti apa data pengguna palsu itu: https://gist.githubusercontent.com/maisonm/e3df4f51d0aced8d02177bd10c43fe20/raw/2343d0e9b4557518efbd8f2765af89319df905f6/dummyUser.js Kami akan mengimpor modul ini ke file rute / api / userRoute.js sehingga kami dapat mengakses pengguna tiruan kami. Biasanya, pengguna akan ditarik dari database, tetapi untuk saat ini, ini berfungsi dengan baik sebagai contoh.",
          "Generating and verifying JWT Tokens",
          "Sekarang kita sudah memiliki semua itu, mari kita masuk ke 'daging & kentang' JWT dan bagaimana kita menggunakannya. Ada dua fungsi JWT yang akan menangani semuanya dalam contoh ini:",
          "jwt.sign() jwt.sign(payload, secretkey, [options, callback]) Fungsi pertama jwt.sign () akan menghasilkan token JWT, menetapkannya ke objek pengguna, dan kemudian mengembalikan token JWT itu sehingga kami dapat meneruskannya ke tempat yang mungkin kami butuhkan. Itu bisa asinkron atau sinkron tergantung jika ada panggilan balik yang disediakan. Parameter payload akan menjadi objek pengguna dalam kasus kami, kunci rahasia dibuat oleh Anda, dan itu bisa apa saja. Parameter panggilan balik adalah tempat kami menangani pengiriman token kami, dan parameter opsi akan menjadi tempat mengatur waktu kedaluwarsa di antara hal-hal lain.Catatan: Penting bahwa dalam produksi Anda TIDAK PERNAH MEMILIKI KUNCI RAHASIA ANDA TAMPAKNYA seperti dalam contoh ini. Ini bukan kode produksi, ini hanyalah contoh cara kerja JWT. Kunci rahasia Anda harus disimpan dalam variabel lingkungan, seperti semua informasi sensitif.",
          "jwt.verify() jwt.verify(token, secretkey, [options, callback]), Fungsi asinkron kedua jwt.verify () akan memverifikasi token pengguna saat rute yang dilindungi diakses. Dibutuhkan token sebagai satu parameter, kunci rahasia yang Anda tetapkan dalam fungsi jwt.sign (), dan kemudian Anda memiliki opsi dan parameter panggilan balik. Callback akan menjadi tempat kita dapat mengakses dan mengirim data yang dilindungi.",
          "Menyatukan Semuanya, Mari kita luangkan waktu sejenak untuk melihat ikhtisar rute / api / userRoutes.js: lihat disini code https://gist.githubusercontent.com/maisonm/b76339d109da61f11225fd2cc9ce5a53/raw/c1b3db381aa42ba7e7e99aa410108aa77994bee1/userRoutes.js ",
          "Mulai dari atas kami hanya mengimpor JWT dan model pengguna tiruan kami. Cukup jelas, jika Anda terbiasa dengan node, jadi mari kita lanjutkan dan diskusikan.Sekarang benar-benar menyenangkan. Online 6 kami memiliki rute POST yang ditemukan di / user / login yang menangani sistem mock login kami. Kami memeriksa untuk memastikan bahwa nama pengguna dan kata sandi cocok dengan pengguna tiruan kami, dan jika demikian kami membuat token JWT untuk pengguna pada baris 14 dengan: Melewati objek pengguna kami, yang dalam hal ini berasal dari model pengguna tiruan di models / dummyUser.js, Kunci rahasia yang dalam hal ini adalah privatekey, Parameter opsi {expiresIn: '1h'}, Akhirnya, panggilan balik yang berisi parameter (err, token)",
          "Jika kesalahan dikembalikan dalam panggilan balik, kami mengirim kode Forbidden (403) untuk menandakan bahwa akses .. terlarang.",
          "Jika tidak ada kesalahan yang dikembalikan dalam panggilan balik, kami mengizinkan akses ke token yang dihasilkan JWT. Sekarang ketika kami melewati objek pengguna {user}, ini adalah bagaimana kami 'melampirkan' token ke data pengguna. Ini memungkinkan kami mengidentifikasi token JWT tertentu dengan data pengguna.",
          "Logging In",
          "Ini seperti apa ketika kita mengakses / pengguna / login melalui POSTman: lihat disini https://cdn-images-1.medium.com/max/800/1*tKPUucRQexEUPMRn7ZdAbg.gif",
          "Jadi di POSTman saya membuat permintaan POST ke rute / user / login dengan data formulir. Saya menyampaikan pasangan nama pengguna dan kunci kata sandi / nilai untuk mensimulasikan pengguna tiruan masuk.",
          "Perhatikan bahwa kata sandi dan nama pengguna cocok dengan kata sandi pengguna tunggal kami. Karena semuanya cocok dan pengguna ‘login’, fungsi jwt.sign () yang ditemukan dalam rute login mengembalikan token JWT yang unik. Sempurna, tepat seperti yang kita inginkan. Token ini yang akan digunakan untuk mengakses rute yang dilindungi kami. Dalam aplikasi produksi, ini akan dikirim ke klien frontend seperti React untuk digunakan ketika klien membuat permintaan untuk rute backend yang dilindungi.",
          "Hanya dengan sedikit menyentuh pada tanggal kedaluwarsa, aplikasi Anda perlu memiliki semacam logika yang memeriksa token yang kedaluwarsa sehingga dapat menangani pengiriman pengguna kembali ke halaman login untuk diberi token baru yang baru. Misalnya, pikirkan jika Anda masuk ke rekening bank Anda. Setelah beberapa menit tidak aktif, Anda biasanya akan keluar dan diminta untuk masuk kembali. Ini berfungsi dua kali lipat karena A) mengeluarkan Anda dari sesi Anda jika Anda lupa pada diri sendiri dan B) itu memberi kesempatan pada aplikasi. untuk menyegarkan otorisasi apa pun yang digunakannya.",
          "Requesting Protected Routes",
          "Sayangnya, langkah terakhir untuk seluruh aliran otorisasi JWT ini. Mari kita mulai dengan POSTman gif lain untuk menunjukkan apa yang akan kita akses, maka saya akan menjelaskan apa yang sedang terjadi.",
          "Pertama inilah yang terjadi jika kami mencoba mengakses rute yang dilindungi tanpa token JWT: lihat sini https://cdn-images-1.medium.com/max/800/1*0iczAqoPTtAkMlrMNBOfhA.gif",
          "403 juga dibuang ketika token tidak valid. Jadi seperti kode yang ditentukan dalam rute / user / login GET mulai pada baris 24, ketika kita gagal mengakses rute yang dilindungi dengan token JWT, panggilan balik di jwt.verify () mengembalikan err. Kesalahan ini memungkinkan kami mengirimkan sinyal kelelawar 403 Terlarang ke apa pun yang gagal meminta rute.",
          "Di sisi lain, ini seperti apa ketika kita mendapatkan sinyal kelelawar 200 OK: lihat disni https://cdn-images-1.medium.com/max/800/1*2gnUYOHgGr_lcCbchf8rBQ.gif",
          "Tunggu apa? Anda mungkin memperhatikan bahwa saya melewati token JWT di tajuk bernama Otorisasi dengan permintaan GET. Anda juga mungkin memperhatikan Bearer yang ditambahkan sebelum token JWT. Biarkan saya jelaskan.",
          "Otorisasi: <type> <credentials> adalah pola yang diperkenalkan oleh W3C di HTTP 1.0. Situs yang menggunakan pola ini kemungkinan besar menerapkan token pembawa OAuth 2.0. Kerangka Otorisasi OAuth 2.0 menetapkan sejumlah persyaratan lain untuk pengesahan otorisasi. Misalnya, membutuhkan penggunaan HTTPS. Ingat, HTTPS membuat pengiriman token dari server ke klien lebih aman. Berikut ini info lebih lanjut tentang Kerangka Kerja OAuth 2.0.",
          "Jadi dengan mengingat hal itu, tajuk Otorisasi kami membutuhkan Bearer sebagai jenisnya, dengan token JWT sebagai kredensial. Mengetahui hal ini, itu membuat penjelasan untuk fungsi checkToken () yang ditemukan pada baris 45 lebih masuk akal. Fungsi ini diteruskan ke rute terlindungi kami seperti:",
          "app.get ('/ pengguna / login', checkToken, (req, res) => {// Callback});",
          "Dalam fungsi checkToken (), kami memeriksa untuk memastikan token tidak terdefinisi, dan kemudian kami membagi req.header menjadi array. Ini karena tajuk Otorisasi kembali sebagai string. Misalnya: Bearer jh3uj3jedjd3.",
          "Kita tahu bahwa metode split () mengubah string menjadi array sub-string. Jadi kita dapat dengan aman berasumsi bahwa tajuk yang sekarang terpecah terlihat seperti ['Pembawa', 'jh3uj3jedjd3']. Itulah sebabnya pada baris 50 kita menetapkan const token = bearer [1] dengan indeks 1. Jelas dari contoh bahwa token berada pada indeks 1 dalam array.",
          "Setelah ini, pada baris 52 set atur req.token sama dengan token yang kita dapatkan dari header Otorisasi. Kemudian kita gunakan next () untuk memanggil pengendali rute berikutnya.",
          "Akhirnya, kami menangani tajuk yang tidak ditentukan dengan mengirimkan ole 'fashion Forbidden 403 yang bagus.",
          "Accessing the Protected Route",
          "Jadi, kami telah melewati tajuk Otorisasi dengan token ke rute yang dilindungi. Kami telah memverifikasi token untuk tidak ditentukan, dan kami telah menghapus string Bearer dari header di fungsi checkToken (), meninggalkan kami hanya dengan token. Sekarang, kita perlu menggunakan potongan terakhir dari teka-teki: jwt.verify () untuk mendapatkan akses ke data yang diotorisasi. Begini cara kerjanya.",
          "jwt.verify (token, 'privatekey', [options, callback]) akan menggunakan req.token sebagai parameter token, dalam hal ini 'privatekey' sebagai kunci rahasia, dan kemudian panggilan kembali kita akan terlihat seperti: (err, Authorized data ) => {// panggilan balik}. Jika parameter err dikembalikan, sama seperti yang lain akan menandakan untuk kemudian mengembalikan respons Terlarang 403 untuk membiarkan siapa pun yang tahu verifikasi token gagal. Jika kami melewati kunci rahasia yang salah di sini, kami akan selalu mendapatkan kembali kode respons 403.",
          "Parameter data resmi adalah roti dan mentega. Ini berisi semua data yang dilindungi yang kami minta. Berikut adalah data pengguna yang terlihat seperti ketika berhasil diakses dari POSTman: lihat sini https://gist.github.com/maisonm/cf4e669e311269e162482b7f329d1331#file-authorizeddata-js",
          "Kami menerima data pengguna ini karena ini adalah apa yang kami berikan sebagai parameter payload dari fungsi jwt.sign (). Perhatikan pasangan kunci / nilai 'iat' dan 'exp'. iat merujuk pada 'dikeluarkan pada' yang merupakan tindakan default. Ini adalah waktu token dikeluarkan di. Ini diatur ke default kecuali noTimeStamp dideklarasikan. exp adalah opsi kedaluwarsa yang kami lewati di jwt.sign (). Ini hanya saat token berakhir. Dari sini, Anda dapat mengirim data ini ke klien Anda, dan lakukan sesuai keinginan Anda.",
          "Contoh cepat menggunakan fetch () dari klien untuk meminta akses ke rute yang dilindungi: ",
          "Bayangkan ketika pengguna login, bahwa token JWT dihasilkan dan kemudian diteruskan ke klien untuk penyimpanan. Berpura-pura sejenak bahwa authToken adalah variabel yang menyimpan token JWT yang valid. Mengirim tajuk Otorisasi dengan permintaan pengambilan memungkinkan akses ke rute yang dilindungi mengingat token yang disahkan valid. Code lihat sini https://shrib.com/#gDB16RQLc8-7UmftPJJX"
        ],
        "summarize": "JSON Web Token (JWT) adalah cara untuk menghasilkan token auth. Ini adalah standar terbuka (RFC 7519) yang menetapkan cara sederhana untuk mentransmisikan informasi antara klien dan server dengan aman sebagai objek JSON.",
        "detail": [
          "JWT",
          "Authorization, public and private pages"
        ],
        "useable_link": [
          {
            "url": "https://medium.com/@maison.moa/using-jwt-json-web-tokens-to-authorize-users-and-protect-api-routes-3e04a1453c3e",
            "title": "Using JWT to authorize users and protect API routes "
          },
          {
            "url": "https://medium.com/@rajaraodv/securing-react-redux-apps-with-jwt-tokens-fcfe81356ea0",
            "title": "Other Source : Securing React Redux Apps With JWT Tokens  "
          }
        ]
      }
    ]
  },
  {
    "id": 5,
    "title": "Styling in React",
    "master": [
      {
        "title": "CSS Vs JS",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Styled-components",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Component libraries comparison: SemanticUI, MaterialUI, Rebass, and React-Bootstrap",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Storybook",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      }
    ]
  },
  {
    "id": 6,
    "title": "Introduction to Redux",
    "master": [
      {
        "title": "Introduction to functional programming",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": [],
        "detail": [
          "Data and behaviour",
          "Data in, data out",
          "Mutations",
          "Pure functions"
        ]
      },
      {
        "title": "Redux Principles",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": [],
        "detail": [
          "Store, Reducers, Actions",
          "Unique source of truth"
        ]
      },
      {
        "title": "React-Redux: Provider and Connect",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Build your own version of Redux using TDD",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Fetching data from the server to Redux",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Configure Redux from scratch in a React app",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      }
    ]
  },
  {
    "id": 7,
    "title": "Introduction to Testing in JS",
    "master": [
      {
        "title": "Build your own test framework in JavaScript",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Testing Redux using Jest",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "Mocking and testing API calls",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      },
      {
        "title": "White-box testing Vs. Black-box testing",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "useable_link": []
      }
    ]
  },
  {
    "id": 8,
    "title": "Advanced Pattern I",
    "master": [
      {
        "title": "Functional programming (FP)",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "detail": [
          "Composing React components"
        ],
        "useable_link": []
      },
      {
        "title": "Advanced React patterns to reuse functionality across components",
        "competence": [],
        "course": [
          {
            "title":"",
            "content":""
          }
        ],
        "keywords": "",
        "notes": "",
        "summarize": "",
        "detail": [
          "Higher-Order Components (HOCs)",
          "Declarative composition using the Render Props (AKA function as children)"
        ],
        "useable_link": []
      }
    ]
  }
]